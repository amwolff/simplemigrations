// AUTOGENERATED BY storj.io/dbx
// DO NOT EDIT.

package fruitsdbx

import (
	"bytes"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode"

	"github.com/jackc/pgx/v5/pgconn"
	_ "github.com/jackc/pgx/v5/stdlib"
)

// Prevent conditional imports from causing build failures.
var _ = strconv.Itoa
var _ = strings.LastIndex
var _ = fmt.Sprint
var _ sync.Mutex

var (
	WrapErr     = func(err *Error) error { return err }
	Logger      func(format string, args ...any)
	ShouldRetry func(driver string, err error) bool

	errTooManyRows       = errors.New("too many rows")
	errUnsupportedDriver = errors.New("unsupported driver")
	errEmptyUpdate       = errors.New("empty update")
)

func logError(format string, args ...any) {
	if Logger != nil {
		Logger(format, args...)
	}
}

type ErrorCode int

const (
	ErrorCode_Unknown ErrorCode = iota
	ErrorCode_UnsupportedDriver
	ErrorCode_NoRows
	ErrorCode_TxDone
	ErrorCode_TooManyRows
	ErrorCode_ConstraintViolation
	ErrorCode_EmptyUpdate
)

type Error struct {
	Err         error
	Code        ErrorCode
	Driver      string
	Constraint  string
	QuerySuffix string
}

func (e *Error) Error() string {
	return e.Err.Error()
}

func (e *Error) Unwrap() error {
	return e.Err
}

func wrapErr(e *Error) error {
	if WrapErr == nil {
		return e
	}
	return WrapErr(e)
}

func makeErr(err error) error {
	if err == nil {
		return nil
	}
	var e *Error
	if errors.As(err, &e) {
		return wrapErr(e)
	}
	e = &Error{Err: err}
	switch {
	case errors.Is(err, sql.ErrNoRows):
		e.Code = ErrorCode_NoRows
	case errors.Is(err, sql.ErrTxDone):
		e.Code = ErrorCode_TxDone
	}
	return wrapErr(e)
}

func shouldRetry(driver string, err error) bool {
	if ShouldRetry == nil {
		return false
	}
	return ShouldRetry(driver, err)
}

func unsupportedDriver(driver string) error {
	return wrapErr(&Error{
		Err:    errUnsupportedDriver,
		Code:   ErrorCode_UnsupportedDriver,
		Driver: driver,
	})
}

func emptyUpdate() error {
	return wrapErr(&Error{
		Err:  errEmptyUpdate,
		Code: ErrorCode_EmptyUpdate,
	})
}

func tooManyRows(query_suffix string) error {
	return wrapErr(&Error{
		Err:         errTooManyRows,
		Code:        ErrorCode_TooManyRows,
		QuerySuffix: query_suffix,
	})
}

func constraintViolation(err error, constraint string) error {
	return wrapErr(&Error{
		Err:        err,
		Code:       ErrorCode_ConstraintViolation,
		Constraint: constraint,
	})
}

func closeRows(rows *sql.Rows, err *error) {
	rowsErr := rows.Err()
	closeErr := rows.Close()
	if *err != nil {
		// throw away errors from .Err() and .Close(), if any; they are almost certainly less important
		// than the error we already have
		return
	}
	if rowsErr != nil {
		// throw away error from .Close(), if any; it is probably less important
		*err = rowsErr
		return
	}
	*err = closeErr
}

type driver interface {
	ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
}

type DB struct {
	*sql.DB
	dbMethods

	Hooks struct {
		Now func() time.Time
	}

	driver string
}

func Open(driver, source string) (db *DB, err error) {
	var sql_db *sql.DB
	switch driver {
	case "pgx":
		sql_db, err = openpgx(source)
	default:
		return nil, unsupportedDriver(driver)
	}
	if err != nil {
		return nil, makeErr(err)
	}
	defer func(sql_db *sql.DB) {
		if err != nil {
			_ = sql_db.Close()
		}
	}(sql_db)

	if err := sql_db.Ping(); err != nil {
		return nil, makeErr(err)
	}

	db = &DB{
		DB: sql_db,

		driver: driver,
	}
	db.Hooks.Now = time.Now

	switch driver {
	case "pgx":
		db.dbMethods = newpgx(db)
	default:
		return nil, unsupportedDriver(driver)
	}

	return db, nil
}

func (obj *DB) Close() (err error) {
	return obj.makeErr(obj.DB.Close())
}

func (obj *DB) Open(ctx context.Context) (*Tx, error) {
	tx, err := obj.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return &Tx{
		Tx:        tx,
		txMethods: obj.wrapTx(tx),
	}, nil
}

func DeleteAll(ctx context.Context, db *DB) (int64, error) {
	tx, err := db.Open(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err == nil {
			err = db.makeErr(tx.Commit())
			return
		}

		if err_rollback := tx.Rollback(); err_rollback != nil {
			logError("delete-all: rollback failed: %v", db.makeErr(err_rollback))
		}
	}()
	return tx.deleteAll(ctx)
}

type Tx struct {
	Tx *sql.Tx
	txMethods
}

func (tx *Tx) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	return tx.Tx.ExecContext(ctx, query, args...)
}
func (tx *Tx) QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error) {
	return tx.Tx.QueryContext(ctx, query, args...)
}
func (tx *Tx) QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row {
	return tx.Tx.QueryRowContext(ctx, query, args...)
}

type dialectTx struct {
	tx *sql.Tx
}

func (tx *dialectTx) Commit() (err error) {
	return makeErr(tx.tx.Commit())
}

func (tx *dialectTx) Rollback() (err error) {
	return makeErr(tx.tx.Rollback())
}

type pgxImpl struct {
	db      *DB
	dialect __sqlbundle_pgx
	driver  driver
	txn     bool
}

func (obj *pgxImpl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *pgxImpl) logStmt(stmt string, args ...any) {
	pgxLogStmt(stmt, args...)
}

func (obj *pgxImpl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

func (obj *pgxImpl) shouldRetry(err error) bool {
	return !obj.txn && shouldRetry(obj.db.driver, err)
}

type pgxImpl_retryingRow struct {
	obj   *pgxImpl
	ctx   context.Context
	query string
	args  []any
}

func (obj *pgxImpl) queryRowContext(ctx context.Context, query string, args ...any) *pgxImpl_retryingRow {
	return &pgxImpl_retryingRow{
		obj:   obj,
		ctx:   ctx,
		query: query,
		args:  args,
	}
}

func (rows *pgxImpl_retryingRow) Scan(dest ...any) error {
	for {
		err := rows.obj.driver.QueryRowContext(rows.ctx, rows.query, rows.args...).Scan(dest...)
		if err != nil {
			if rows.obj.shouldRetry(err) {
				continue
			}
			// caller will wrap this error
			return err
		}
		return nil
	}
}

type pgxDB struct {
	db *DB
	*pgxImpl
}

func newpgx(db *DB) *pgxDB {
	return &pgxDB{
		db: db,
		pgxImpl: &pgxImpl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *pgxDB) Schema() []string {
	return []string{

		`CREATE TABLE fruits (
	id integer NOT NULL,
	name varchar(50) NOT NULL,
	color varchar(20) NOT NULL,
	calories_per_100g integer NOT NULL,
	is_tropical boolean NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE schema_versions (
	number integer NOT NULL,
	comment text NOT NULL,
	PRIMARY KEY ( number )
)`,
	}
}

func (obj *pgxDB) DropSchema() []string {
	return []string{

		`DROP TABLE IF EXISTS schema_versions`,

		`DROP TABLE IF EXISTS fruits`,
	}
}

func (obj *pgxDB) wrapTx(tx *sql.Tx) txMethods {
	return &pgxTx{
		dialectTx: dialectTx{tx: tx},
		pgxImpl: &pgxImpl{
			db:     obj.db,
			driver: tx,
			txn:    true,
		},
	}
}

type pgxTx struct {
	dialectTx
	*pgxImpl
}

func pgxLogStmt(stmt string, args ...any) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pretty []any

func (p pretty) Format(f fmt.State, c rune) {
	_, _ = fmt.Fprint(f, "[")
nextval:
	for i, val := range p {
		if i > 0 {
			_, _ = fmt.Fprint(f, ", ")
		}
		rv := reflect.ValueOf(val)
		if rv.Kind() == reflect.Ptr {
			if rv.IsNil() {
				_, _ = fmt.Fprint(f, "NULL")
				continue
			}
			val = rv.Elem().Interface()
		}
		switch v := val.(type) {
		case string:
			_, _ = fmt.Fprintf(f, "%q", v)
		case time.Time:
			_, _ = fmt.Fprintf(f, "%s", v.Format(time.RFC3339Nano))
		case []byte:
			for _, b := range v {
				if !unicode.IsPrint(rune(b)) {
					_, _ = fmt.Fprintf(f, "%#x", v)
					continue nextval
				}
			}
			_, _ = fmt.Fprintf(f, "%q", v)
		default:
			_, _ = fmt.Fprintf(f, "%v", v)
		}
	}
	_, _ = fmt.Fprint(f, "]")
}

type Fruit struct {
	Id              int
	Name            string
	Color           string
	CaloriesPer100g int
	IsTropical      bool
}

func (Fruit) _Table() string { return "fruits" }

type Fruit_Update_Fields struct {
}

type Fruit_Id_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Fruit_Id(v int) Fruit_Id_Field {
	return Fruit_Id_Field{_set: true, _value: v}
}

func (f Fruit_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Fruit_Name_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Fruit_Name(v string) Fruit_Name_Field {
	return Fruit_Name_Field{_set: true, _value: v}
}

func (f Fruit_Name_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Fruit_Color_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Fruit_Color(v string) Fruit_Color_Field {
	return Fruit_Color_Field{_set: true, _value: v}
}

func (f Fruit_Color_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Fruit_CaloriesPer100g_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Fruit_CaloriesPer100g(v int) Fruit_CaloriesPer100g_Field {
	return Fruit_CaloriesPer100g_Field{_set: true, _value: v}
}

func (f Fruit_CaloriesPer100g_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Fruit_IsTropical_Field struct {
	_set   bool
	_null  bool
	_value bool
}

func Fruit_IsTropical(v bool) Fruit_IsTropical_Field {
	return Fruit_IsTropical_Field{_set: true, _value: v}
}

func (f Fruit_IsTropical_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type SchemaVersion struct {
	Number  int
	Comment string
}

func (SchemaVersion) _Table() string { return "schema_versions" }

type SchemaVersion_Update_Fields struct {
}

type SchemaVersion_Number_Field struct {
	_set   bool
	_null  bool
	_value int
}

func SchemaVersion_Number(v int) SchemaVersion_Number_Field {
	return SchemaVersion_Number_Field{_set: true, _value: v}
}

func (f SchemaVersion_Number_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type SchemaVersion_Comment_Field struct {
	_set   bool
	_null  bool
	_value string
}

func SchemaVersion_Comment(v string) SchemaVersion_Comment_Field {
	return SchemaVersion_Comment_Field{_set: true, _value: v}
}

func (f SchemaVersion_Comment_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func toUTC(t time.Time) time.Time {
	return t.UTC()
}

func toDate(t time.Time) time.Time {
	// keep up the minute portion so that translations between timezones will
	// continue to reflect properly.
	return t.Truncate(time.Minute)
}

//
// runtime support for building sql statements
//

type __sqlbundle_SQL interface {
	Render() string

	private()
}

type __sqlbundle_Dialect interface {
	// Rebind gives the opportunity to rewrite provided SQL into a SQL dialect.
	Rebind(sql string) string
}

type __sqlbundle_RenderOp int

const (
	__sqlbundle_NoFlatten __sqlbundle_RenderOp = iota
	__sqlbundle_NoTerminate
)

func __sqlbundle_RenderAll(dialect __sqlbundle_Dialect, sqls []__sqlbundle_SQL, ops ...__sqlbundle_RenderOp) []string {
	var rs []string
	for _, sql := range sqls {
		rs = append(rs, __sqlbundle_Render(dialect, sql, ops...))
	}
	return rs
}

func __sqlbundle_Render(dialect __sqlbundle_Dialect, sql __sqlbundle_SQL, ops ...__sqlbundle_RenderOp) string {
	out := sql.Render()

	flatten := true
	terminate := true
	for _, op := range ops {
		switch op {
		case __sqlbundle_NoFlatten:
			flatten = false
		case __sqlbundle_NoTerminate:
			terminate = false
		}
	}

	if flatten {
		out = __sqlbundle_flattenSQL(out)
	}
	if terminate {
		out += ";"
	}

	return dialect.Rebind(out)
}

func __sqlbundle_flattenSQL(x string) string {
	// trim whitespace from beginning and end
	s, e := 0, len(x)-1
	for s < len(x) && (x[s] == ' ' || x[s] == '\t' || x[s] == '\n') {
		s++
	}
	for s <= e && (x[e] == ' ' || x[e] == '\t' || x[e] == '\n') {
		e--
	}
	if s > e {
		return ""
	}
	x = x[s : e+1]

	// check for whitespace that needs fixing
	wasSpace := false
	for i := 0; i < len(x); i++ {
		r := x[i]
		justSpace := r == ' '
		if (wasSpace && justSpace) || r == '\t' || r == '\n' {
			// whitespace detected, start writing a new string
			var result strings.Builder
			result.Grow(len(x))
			if wasSpace {
				result.WriteString(x[:i-1])
			} else {
				result.WriteString(x[:i])
			}
			for p := i; p < len(x); p++ {
				for p < len(x) && (x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteByte(' ')

				start := p
				for p < len(x) && !(x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteString(x[start:p])
			}

			return result.String()
		}
		wasSpace = justSpace
	}

	// no problematic whitespace found
	return x
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_cockroach struct{}

func (p __sqlbundle_cockroach) Rebind(sql string) string {
	return __sqlbundle_postgres{}.Rebind(sql)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_pgx struct{}

func (p __sqlbundle_pgx) Rebind(sql string) string {
	return __sqlbundle_postgres{}.Rebind(sql)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_pgxcockroach struct{}

func (p __sqlbundle_pgxcockroach) Rebind(sql string) string {
	return __sqlbundle_postgres{}.Rebind(sql)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_postgres struct{}

func (p __sqlbundle_postgres) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_spanner struct{}

func (p __sqlbundle_spanner) Rebind(sql string) string {
	return sql
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_sqlite3 struct{}

func (s __sqlbundle_sqlite3) Rebind(sql string) string {
	return sql
}

type __sqlbundle_Literal string

func (__sqlbundle_Literal) private() {}

func (l __sqlbundle_Literal) Render() string { return string(l) }

type __sqlbundle_Literals struct {
	Join string
	SQLs []__sqlbundle_SQL
}

func (__sqlbundle_Literals) private() {}

func (l __sqlbundle_Literals) Render() string {
	var out bytes.Buffer

	first := true
	for _, sql := range l.SQLs {
		if sql == nil {
			continue
		}
		if !first {
			out.WriteString(l.Join)
		}
		first = false
		out.WriteString(sql.Render())
	}

	return out.String()
}

type __sqlbundle_Condition struct {
	// set at compile/embed time
	Name  string
	Left  string
	Equal bool
	Right string

	// set at runtime
	Null bool
}

func (*__sqlbundle_Condition) private() {}

func (c *__sqlbundle_Condition) Render() string {
	// TODO(jeff): maybe check if we can use placeholders instead of the
	// literal null: this would make the templates easier.

	switch {
	case c.Equal && c.Null:
		return c.Left + " is null"
	case c.Equal && !c.Null:
		return c.Left + " = " + c.Right
	case !c.Equal && c.Null:
		return c.Left + " is not null"
	case !c.Equal && !c.Null:
		return c.Left + " != " + c.Right
	default:
		panic("unhandled case")
	}
}

type __sqlbundle_Hole struct {
	// set at compiile/embed time
	Name string

	// set at runtime or possibly embed time
	SQL __sqlbundle_SQL
}

func (*__sqlbundle_Hole) private() {}

func (h *__sqlbundle_Hole) Render() string {
	if h.SQL == nil {
		return ""
	}
	return h.SQL.Render()
}

//
// end runtime support for building sql statements
//

type Number_Row struct {
	Number int
}

func (obj *pgxImpl) Create_SchemaVersion(ctx context.Context,
	schema_version_number SchemaVersion_Number_Field,
	schema_version_comment SchemaVersion_Comment_Field) (
	schema_version *SchemaVersion, err error) {
	__number_val := schema_version_number.value()
	__comment_val := schema_version_comment.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO schema_versions ( number, comment ) VALUES ( ?, ? ) RETURNING schema_versions.number, schema_versions.comment")

	var __values []any
	__values = append(__values, __number_val, __comment_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	schema_version = &SchemaVersion{}
	err = obj.queryRowContext(ctx, __stmt, __values...).Scan(&schema_version.Number, &schema_version.Comment)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return schema_version, nil

}

func (obj *pgxImpl) First_SchemaVersion_Number_OrderBy_Desc_Number(ctx context.Context) (
	row *Number_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT schema_versions.number FROM schema_versions ORDER BY schema_versions.number DESC LIMIT 1 OFFSET 0")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	for {
		row, err = func() (row *Number_Row, err error) {
			__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
			if err != nil {
				return nil, err
			}
			defer closeRows(__rows, &err)

			if !__rows.Next() {
				return nil, nil
			}

			row = &Number_Row{}
			err = __rows.Scan(&row.Number)
			if err != nil {
				return nil, err
			}

			return row, nil
		}()
		if err != nil {
			if obj.shouldRetry(err) {
				continue
			}
			return nil, obj.makeErr(err)
		}
		return row, nil
	}

}

func (impl pgxImpl) isConstraintError(err error) (constraint string, ok bool) {
	if e, ok := err.(*pgconn.PgError); ok {
		if e.Code[:2] == "23" {
			return e.ConstraintName, true
		}
	}
	return "", false
}

func (obj *pgxImpl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM schema_versions;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM fruits;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

type Methods interface {
	Create_SchemaVersion(ctx context.Context,
		schema_version_number SchemaVersion_Number_Field,
		schema_version_comment SchemaVersion_Comment_Field) (
		schema_version *SchemaVersion, err error)

	First_SchemaVersion_Number_OrderBy_Desc_Number(ctx context.Context) (
		row *Number_Row, err error)
}

type TxMethods interface {
	Methods

	Rebind(s string) string
	Commit() error
	Rollback() error
}

type txMethods interface {
	TxMethods

	deleteAll(ctx context.Context) (int64, error)
	makeErr(err error) error
}

type DBMethods interface {
	Methods

	Schema() []string
	DropSchema() []string

	Rebind(sql string) string
}

type dbMethods interface {
	DBMethods

	wrapTx(tx *sql.Tx) txMethods
	makeErr(err error) error
}

func openpgx(source string) (*sql.DB, error) {
	return sql.Open("pgx", source)
}
